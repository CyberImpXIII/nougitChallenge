// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  author: (where?: AuthorWhereInput) => Promise<boolean>;
  entry: (where?: EntryWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  author: (where: AuthorWhereUniqueInput) => AuthorNullablePromise;
  authors: (args?: {
    where?: AuthorWhereInput;
    orderBy?: AuthorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Author>;
  authorsConnection: (args?: {
    where?: AuthorWhereInput;
    orderBy?: AuthorOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => AuthorConnectionPromise;
  entry: (where: EntryWhereUniqueInput) => EntryNullablePromise;
  entries: (args?: {
    where?: EntryWhereInput;
    orderBy?: EntryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Entry>;
  entriesConnection: (args?: {
    where?: EntryWhereInput;
    orderBy?: EntryOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => EntryConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createAuthor: (data: AuthorCreateInput) => AuthorPromise;
  updateAuthor: (args: {
    data: AuthorUpdateInput;
    where: AuthorWhereUniqueInput;
  }) => AuthorPromise;
  updateManyAuthors: (args: {
    data: AuthorUpdateManyMutationInput;
    where?: AuthorWhereInput;
  }) => BatchPayloadPromise;
  upsertAuthor: (args: {
    where: AuthorWhereUniqueInput;
    create: AuthorCreateInput;
    update: AuthorUpdateInput;
  }) => AuthorPromise;
  deleteAuthor: (where: AuthorWhereUniqueInput) => AuthorPromise;
  deleteManyAuthors: (where?: AuthorWhereInput) => BatchPayloadPromise;
  createEntry: (data: EntryCreateInput) => EntryPromise;
  updateEntry: (args: {
    data: EntryUpdateInput;
    where: EntryWhereUniqueInput;
  }) => EntryPromise;
  updateManyEntries: (args: {
    data: EntryUpdateManyMutationInput;
    where?: EntryWhereInput;
  }) => BatchPayloadPromise;
  upsertEntry: (args: {
    where: EntryWhereUniqueInput;
    create: EntryCreateInput;
    update: EntryUpdateInput;
  }) => EntryPromise;
  deleteEntry: (where: EntryWhereUniqueInput) => EntryPromise;
  deleteManyEntries: (where?: EntryWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  author: (
    where?: AuthorSubscriptionWhereInput
  ) => AuthorSubscriptionPayloadSubscription;
  entry: (
    where?: EntrySubscriptionWhereInput
  ) => EntrySubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type AuthorOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "picture_ASC"
  | "picture_DESC"
  | "score_ASC"
  | "score_DESC";

export type EntryOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "date_ASC"
  | "date_DESC"
  | "popularity_ASC"
  | "popularity_DESC"
  | "isTrending_ASC"
  | "isTrending_DESC"
  | "title_ASC"
  | "title_DESC"
  | "description_ASC"
  | "description_DESC"
  | "numComments_ASC"
  | "numComments_DESC"
  | "thumbnail_ASC"
  | "thumbnail_DESC"
  | "codeSubmissionTotal_ASC"
  | "codeSubmissionTotal_DESC"
  | "pledgeTotal_ASC"
  | "pledgeTotal_DESC"
  | "pledgeGoal_ASC"
  | "pledgeGoal_DESC"
  | "pledgerCount_ASC"
  | "pledgerCount_DESC"
  | "status_ASC"
  | "status_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export interface EntryUpdateInput {
  author?: Maybe<AuthorUpdateOneRequiredInput>;
  date?: Maybe<String>;
  popularity?: Maybe<Float>;
  isTrending?: Maybe<Boolean>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  numComments?: Maybe<Int>;
  thumbnail?: Maybe<String>;
  codeSubmissionTotal?: Maybe<Int>;
  pledgeTotal?: Maybe<Float>;
  pledgeGoal?: Maybe<Float>;
  pledgerCount?: Maybe<Int>;
  status?: Maybe<Int>;
}

export type AuthorWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export type EntryWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface AuthorWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  picture?: Maybe<String>;
  picture_not?: Maybe<String>;
  picture_in?: Maybe<String[] | String>;
  picture_not_in?: Maybe<String[] | String>;
  picture_lt?: Maybe<String>;
  picture_lte?: Maybe<String>;
  picture_gt?: Maybe<String>;
  picture_gte?: Maybe<String>;
  picture_contains?: Maybe<String>;
  picture_not_contains?: Maybe<String>;
  picture_starts_with?: Maybe<String>;
  picture_not_starts_with?: Maybe<String>;
  picture_ends_with?: Maybe<String>;
  picture_not_ends_with?: Maybe<String>;
  score?: Maybe<Float>;
  score_not?: Maybe<Float>;
  score_in?: Maybe<Float[] | Float>;
  score_not_in?: Maybe<Float[] | Float>;
  score_lt?: Maybe<Float>;
  score_lte?: Maybe<Float>;
  score_gt?: Maybe<Float>;
  score_gte?: Maybe<Float>;
  AND?: Maybe<AuthorWhereInput[] | AuthorWhereInput>;
  OR?: Maybe<AuthorWhereInput[] | AuthorWhereInput>;
  NOT?: Maybe<AuthorWhereInput[] | AuthorWhereInput>;
}

export interface EntryCreateInput {
  id?: Maybe<ID_Input>;
  author: AuthorCreateOneInput;
  date: String;
  popularity: Float;
  isTrending: Boolean;
  title: String;
  description: String;
  numComments: Int;
  thumbnail: String;
  codeSubmissionTotal: Int;
  pledgeTotal: Float;
  pledgeGoal: Float;
  pledgerCount: Int;
  status: Int;
}

export interface AuthorUpsertNestedInput {
  update: AuthorUpdateDataInput;
  create: AuthorCreateInput;
}

export interface AuthorUpdateManyMutationInput {
  name?: Maybe<String>;
  picture?: Maybe<String>;
  score?: Maybe<Float>;
}

export interface AuthorUpdateOneRequiredInput {
  create?: Maybe<AuthorCreateInput>;
  update?: Maybe<AuthorUpdateDataInput>;
  upsert?: Maybe<AuthorUpsertNestedInput>;
  connect?: Maybe<AuthorWhereUniqueInput>;
}

export interface AuthorCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  picture: String;
  score: Float;
}

export interface AuthorUpdateInput {
  name?: Maybe<String>;
  picture?: Maybe<String>;
  score?: Maybe<Float>;
}

export interface AuthorSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<AuthorWhereInput>;
  AND?: Maybe<AuthorSubscriptionWhereInput[] | AuthorSubscriptionWhereInput>;
  OR?: Maybe<AuthorSubscriptionWhereInput[] | AuthorSubscriptionWhereInput>;
  NOT?: Maybe<AuthorSubscriptionWhereInput[] | AuthorSubscriptionWhereInput>;
}

export interface EntryWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  author?: Maybe<AuthorWhereInput>;
  date?: Maybe<String>;
  date_not?: Maybe<String>;
  date_in?: Maybe<String[] | String>;
  date_not_in?: Maybe<String[] | String>;
  date_lt?: Maybe<String>;
  date_lte?: Maybe<String>;
  date_gt?: Maybe<String>;
  date_gte?: Maybe<String>;
  date_contains?: Maybe<String>;
  date_not_contains?: Maybe<String>;
  date_starts_with?: Maybe<String>;
  date_not_starts_with?: Maybe<String>;
  date_ends_with?: Maybe<String>;
  date_not_ends_with?: Maybe<String>;
  popularity?: Maybe<Float>;
  popularity_not?: Maybe<Float>;
  popularity_in?: Maybe<Float[] | Float>;
  popularity_not_in?: Maybe<Float[] | Float>;
  popularity_lt?: Maybe<Float>;
  popularity_lte?: Maybe<Float>;
  popularity_gt?: Maybe<Float>;
  popularity_gte?: Maybe<Float>;
  isTrending?: Maybe<Boolean>;
  isTrending_not?: Maybe<Boolean>;
  title?: Maybe<String>;
  title_not?: Maybe<String>;
  title_in?: Maybe<String[] | String>;
  title_not_in?: Maybe<String[] | String>;
  title_lt?: Maybe<String>;
  title_lte?: Maybe<String>;
  title_gt?: Maybe<String>;
  title_gte?: Maybe<String>;
  title_contains?: Maybe<String>;
  title_not_contains?: Maybe<String>;
  title_starts_with?: Maybe<String>;
  title_not_starts_with?: Maybe<String>;
  title_ends_with?: Maybe<String>;
  title_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  numComments?: Maybe<Int>;
  numComments_not?: Maybe<Int>;
  numComments_in?: Maybe<Int[] | Int>;
  numComments_not_in?: Maybe<Int[] | Int>;
  numComments_lt?: Maybe<Int>;
  numComments_lte?: Maybe<Int>;
  numComments_gt?: Maybe<Int>;
  numComments_gte?: Maybe<Int>;
  thumbnail?: Maybe<String>;
  thumbnail_not?: Maybe<String>;
  thumbnail_in?: Maybe<String[] | String>;
  thumbnail_not_in?: Maybe<String[] | String>;
  thumbnail_lt?: Maybe<String>;
  thumbnail_lte?: Maybe<String>;
  thumbnail_gt?: Maybe<String>;
  thumbnail_gte?: Maybe<String>;
  thumbnail_contains?: Maybe<String>;
  thumbnail_not_contains?: Maybe<String>;
  thumbnail_starts_with?: Maybe<String>;
  thumbnail_not_starts_with?: Maybe<String>;
  thumbnail_ends_with?: Maybe<String>;
  thumbnail_not_ends_with?: Maybe<String>;
  codeSubmissionTotal?: Maybe<Int>;
  codeSubmissionTotal_not?: Maybe<Int>;
  codeSubmissionTotal_in?: Maybe<Int[] | Int>;
  codeSubmissionTotal_not_in?: Maybe<Int[] | Int>;
  codeSubmissionTotal_lt?: Maybe<Int>;
  codeSubmissionTotal_lte?: Maybe<Int>;
  codeSubmissionTotal_gt?: Maybe<Int>;
  codeSubmissionTotal_gte?: Maybe<Int>;
  pledgeTotal?: Maybe<Float>;
  pledgeTotal_not?: Maybe<Float>;
  pledgeTotal_in?: Maybe<Float[] | Float>;
  pledgeTotal_not_in?: Maybe<Float[] | Float>;
  pledgeTotal_lt?: Maybe<Float>;
  pledgeTotal_lte?: Maybe<Float>;
  pledgeTotal_gt?: Maybe<Float>;
  pledgeTotal_gte?: Maybe<Float>;
  pledgeGoal?: Maybe<Float>;
  pledgeGoal_not?: Maybe<Float>;
  pledgeGoal_in?: Maybe<Float[] | Float>;
  pledgeGoal_not_in?: Maybe<Float[] | Float>;
  pledgeGoal_lt?: Maybe<Float>;
  pledgeGoal_lte?: Maybe<Float>;
  pledgeGoal_gt?: Maybe<Float>;
  pledgeGoal_gte?: Maybe<Float>;
  pledgerCount?: Maybe<Int>;
  pledgerCount_not?: Maybe<Int>;
  pledgerCount_in?: Maybe<Int[] | Int>;
  pledgerCount_not_in?: Maybe<Int[] | Int>;
  pledgerCount_lt?: Maybe<Int>;
  pledgerCount_lte?: Maybe<Int>;
  pledgerCount_gt?: Maybe<Int>;
  pledgerCount_gte?: Maybe<Int>;
  status?: Maybe<Int>;
  status_not?: Maybe<Int>;
  status_in?: Maybe<Int[] | Int>;
  status_not_in?: Maybe<Int[] | Int>;
  status_lt?: Maybe<Int>;
  status_lte?: Maybe<Int>;
  status_gt?: Maybe<Int>;
  status_gte?: Maybe<Int>;
  AND?: Maybe<EntryWhereInput[] | EntryWhereInput>;
  OR?: Maybe<EntryWhereInput[] | EntryWhereInput>;
  NOT?: Maybe<EntryWhereInput[] | EntryWhereInput>;
}

export interface EntrySubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<EntryWhereInput>;
  AND?: Maybe<EntrySubscriptionWhereInput[] | EntrySubscriptionWhereInput>;
  OR?: Maybe<EntrySubscriptionWhereInput[] | EntrySubscriptionWhereInput>;
  NOT?: Maybe<EntrySubscriptionWhereInput[] | EntrySubscriptionWhereInput>;
}

export interface AuthorUpdateDataInput {
  name?: Maybe<String>;
  picture?: Maybe<String>;
  score?: Maybe<Float>;
}

export interface EntryUpdateManyMutationInput {
  date?: Maybe<String>;
  popularity?: Maybe<Float>;
  isTrending?: Maybe<Boolean>;
  title?: Maybe<String>;
  description?: Maybe<String>;
  numComments?: Maybe<Int>;
  thumbnail?: Maybe<String>;
  codeSubmissionTotal?: Maybe<Int>;
  pledgeTotal?: Maybe<Float>;
  pledgeGoal?: Maybe<Float>;
  pledgerCount?: Maybe<Int>;
  status?: Maybe<Int>;
}

export interface AuthorCreateOneInput {
  create?: Maybe<AuthorCreateInput>;
  connect?: Maybe<AuthorWhereUniqueInput>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface AggregateEntry {
  count: Int;
}

export interface AggregateEntryPromise
  extends Promise<AggregateEntry>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateEntrySubscription
  extends Promise<AsyncIterator<AggregateEntry>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface EntryPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  date: String;
  popularity: Float;
  isTrending: Boolean;
  title: String;
  description: String;
  numComments: Int;
  thumbnail: String;
  codeSubmissionTotal: Int;
  pledgeTotal: Float;
  pledgeGoal: Float;
  pledgerCount: Int;
  status: Int;
}

export interface EntryPreviousValuesPromise
  extends Promise<EntryPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  date: () => Promise<String>;
  popularity: () => Promise<Float>;
  isTrending: () => Promise<Boolean>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  numComments: () => Promise<Int>;
  thumbnail: () => Promise<String>;
  codeSubmissionTotal: () => Promise<Int>;
  pledgeTotal: () => Promise<Float>;
  pledgeGoal: () => Promise<Float>;
  pledgerCount: () => Promise<Int>;
  status: () => Promise<Int>;
}

export interface EntryPreviousValuesSubscription
  extends Promise<AsyncIterator<EntryPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  date: () => Promise<AsyncIterator<String>>;
  popularity: () => Promise<AsyncIterator<Float>>;
  isTrending: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  numComments: () => Promise<AsyncIterator<Int>>;
  thumbnail: () => Promise<AsyncIterator<String>>;
  codeSubmissionTotal: () => Promise<AsyncIterator<Int>>;
  pledgeTotal: () => Promise<AsyncIterator<Float>>;
  pledgeGoal: () => Promise<AsyncIterator<Float>>;
  pledgerCount: () => Promise<AsyncIterator<Int>>;
  status: () => Promise<AsyncIterator<Int>>;
}

export interface AuthorConnection {
  pageInfo: PageInfo;
  edges: AuthorEdge[];
}

export interface AuthorConnectionPromise
  extends Promise<AuthorConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<AuthorEdge>>() => T;
  aggregate: <T = AggregateAuthorPromise>() => T;
}

export interface AuthorConnectionSubscription
  extends Promise<AsyncIterator<AuthorConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<AuthorEdgeSubscription>>>() => T;
  aggregate: <T = AggregateAuthorSubscription>() => T;
}

export interface EntryConnection {
  pageInfo: PageInfo;
  edges: EntryEdge[];
}

export interface EntryConnectionPromise
  extends Promise<EntryConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<EntryEdge>>() => T;
  aggregate: <T = AggregateEntryPromise>() => T;
}

export interface EntryConnectionSubscription
  extends Promise<AsyncIterator<EntryConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<EntryEdgeSubscription>>>() => T;
  aggregate: <T = AggregateEntrySubscription>() => T;
}

export interface AuthorSubscriptionPayload {
  mutation: MutationType;
  node: Author;
  updatedFields: String[];
  previousValues: AuthorPreviousValues;
}

export interface AuthorSubscriptionPayloadPromise
  extends Promise<AuthorSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = AuthorPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = AuthorPreviousValuesPromise>() => T;
}

export interface AuthorSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<AuthorSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = AuthorSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = AuthorPreviousValuesSubscription>() => T;
}

export interface AuthorPreviousValues {
  id: ID_Output;
  name: String;
  picture: String;
  score: Float;
}

export interface AuthorPreviousValuesPromise
  extends Promise<AuthorPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  picture: () => Promise<String>;
  score: () => Promise<Float>;
}

export interface AuthorPreviousValuesSubscription
  extends Promise<AsyncIterator<AuthorPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  score: () => Promise<AsyncIterator<Float>>;
}

export interface Author {
  id: ID_Output;
  name: String;
  picture: String;
  score: Float;
}

export interface AuthorPromise extends Promise<Author>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  picture: () => Promise<String>;
  score: () => Promise<Float>;
}

export interface AuthorSubscription
  extends Promise<AsyncIterator<Author>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  picture: () => Promise<AsyncIterator<String>>;
  score: () => Promise<AsyncIterator<Float>>;
}

export interface AuthorNullablePromise
  extends Promise<Author | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  picture: () => Promise<String>;
  score: () => Promise<Float>;
}

export interface EntryEdge {
  node: Entry;
  cursor: String;
}

export interface EntryEdgePromise extends Promise<EntryEdge>, Fragmentable {
  node: <T = EntryPromise>() => T;
  cursor: () => Promise<String>;
}

export interface EntryEdgeSubscription
  extends Promise<AsyncIterator<EntryEdge>>,
    Fragmentable {
  node: <T = EntrySubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface EntrySubscriptionPayload {
  mutation: MutationType;
  node: Entry;
  updatedFields: String[];
  previousValues: EntryPreviousValues;
}

export interface EntrySubscriptionPayloadPromise
  extends Promise<EntrySubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = EntryPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = EntryPreviousValuesPromise>() => T;
}

export interface EntrySubscriptionPayloadSubscription
  extends Promise<AsyncIterator<EntrySubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = EntrySubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = EntryPreviousValuesSubscription>() => T;
}

export interface AuthorEdge {
  node: Author;
  cursor: String;
}

export interface AuthorEdgePromise extends Promise<AuthorEdge>, Fragmentable {
  node: <T = AuthorPromise>() => T;
  cursor: () => Promise<String>;
}

export interface AuthorEdgeSubscription
  extends Promise<AsyncIterator<AuthorEdge>>,
    Fragmentable {
  node: <T = AuthorSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface AggregateAuthor {
  count: Int;
}

export interface AggregateAuthorPromise
  extends Promise<AggregateAuthor>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateAuthorSubscription
  extends Promise<AsyncIterator<AggregateAuthor>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface Entry {
  id: ID_Output;
  createdAt: DateTimeOutput;
  date: String;
  popularity: Float;
  isTrending: Boolean;
  title: String;
  description: String;
  numComments: Int;
  thumbnail: String;
  codeSubmissionTotal: Int;
  pledgeTotal: Float;
  pledgeGoal: Float;
  pledgerCount: Int;
  status: Int;
}

export interface EntryPromise extends Promise<Entry>, Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  author: <T = AuthorPromise>() => T;
  date: () => Promise<String>;
  popularity: () => Promise<Float>;
  isTrending: () => Promise<Boolean>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  numComments: () => Promise<Int>;
  thumbnail: () => Promise<String>;
  codeSubmissionTotal: () => Promise<Int>;
  pledgeTotal: () => Promise<Float>;
  pledgeGoal: () => Promise<Float>;
  pledgerCount: () => Promise<Int>;
  status: () => Promise<Int>;
}

export interface EntrySubscription
  extends Promise<AsyncIterator<Entry>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  author: <T = AuthorSubscription>() => T;
  date: () => Promise<AsyncIterator<String>>;
  popularity: () => Promise<AsyncIterator<Float>>;
  isTrending: () => Promise<AsyncIterator<Boolean>>;
  title: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  numComments: () => Promise<AsyncIterator<Int>>;
  thumbnail: () => Promise<AsyncIterator<String>>;
  codeSubmissionTotal: () => Promise<AsyncIterator<Int>>;
  pledgeTotal: () => Promise<AsyncIterator<Float>>;
  pledgeGoal: () => Promise<AsyncIterator<Float>>;
  pledgerCount: () => Promise<AsyncIterator<Int>>;
  status: () => Promise<AsyncIterator<Int>>;
}

export interface EntryNullablePromise
  extends Promise<Entry | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  author: <T = AuthorPromise>() => T;
  date: () => Promise<String>;
  popularity: () => Promise<Float>;
  isTrending: () => Promise<Boolean>;
  title: () => Promise<String>;
  description: () => Promise<String>;
  numComments: () => Promise<Int>;
  thumbnail: () => Promise<String>;
  codeSubmissionTotal: () => Promise<Int>;
  pledgeTotal: () => Promise<Float>;
  pledgeGoal: () => Promise<Float>;
  pledgerCount: () => Promise<Int>;
  status: () => Promise<Int>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "Entry",
    embedded: false
  },
  {
    name: "Author",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
